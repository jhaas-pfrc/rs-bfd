<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC1997 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1997.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4271 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4271.xml">
<!ENTITY RFC4272 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4272.xml">
<!ENTITY RFC4760 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4760.xml">
<!ENTITY RFC5880 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5880.xml">
<!ENTITY RFC5881 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5881.xml">
<!ENTITY RFC7606 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7606.xml">
<!ENTITY RFC7947 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7947.xml">
<!--ENTITY NH-COST SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-idr-bgp-nh-cost.xml"-->
]>
<?rfc comments="yes"?>
<?rfc compact="yes"?>
<?rfc inline="yes"?>
<?rfc sortrefs="yes"?>
<?rfc subcompact="yes"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc tocompact="yes"?>


<rfc category="std" docName="draft-ietf-idr-rs-bfd-03">
	<front>
		<title abbrev="Making RSes aware of IXP Data Link Failures">Making Route Servers Aware of Data Link Failures at IXPs</title>

		<author fullname="Randy Bush" initials="R." surname="Bush">
			<organization>Internet Initiative Japan</organization>
			<address>
				<postal>
					<street>5147 Crystal Springs</street>
					<city>Bainbridge Island</city>
					<region>Washington</region>
					<code>98110</code>
					<country>US</country>
				</postal>
				<email>randy@psg.com</email>
			</address>
		</author>

		<author fullname="Jeffrey Haas" initials="J." surname="Haas">
			<organization>Juniper Networks, Inc.</organization>
			<address>
				<postal>
					<street>1133 Innovation Way</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94089</code>
					<country>US</country>
				</postal>
				<email>jhaas@juniper.net</email>
			</address>
		</author>

		<author fullname="John G. Scudder" initials="J." surname="Scudder">
			<organization>Juniper Networks, Inc.</organization>
			<address>
				<postal>
					<street>1133 Innovation Way</street>
					<city>Sunnyvale</city>
					<region>CA</region>
					<code>94089</code>
					<country>US</country>
				</postal>
				<email>jgs@juniper.net</email>
			</address>
		</author>

		<author fullname="Arnold Nipper" initials="A." surname="Nipper">
			<organization>DE-CIX Management GmbH</organization>
			<address>
				<postal>
					<street>Lichtstrasse 43i</street>
					<city>Cologne</city>
					<code>50825</code>
					<country>Germany</country>
				</postal>
				<email>arnold.nipper@de-cix.net</email>
			</address>
		</author>
		
		<author fullname="Thomas King" initials="T." surname="King" role="editor">
			<organization>DE-CIX Management GmbH</organization>
			<address>
				<postal>
					<street>Lichtstrasse 43i</street>
					<city>Cologne</city>
					<code>50825</code>
					<country>Germany</country>
				</postal>
				<email>thomas.king@de-cix.net</email>
			</address>
		</author>

		<date month="March" year="2017" />

		<abstract>
			<t>
				When BGP route servers are used, the data plane is not
				congruent with the control plane. Therefore, peers at an
				Internet exchange can lose data connectivity without the
				control plane being aware of it, and packets are lost. This
				document proposes the use of a newly defined BGP Subsequent
				Address Family Identifier (SAFI) both to allow the route
				server to request its clients use BFD to track data plane
				connectivity to their peers' addresses, and for the clients to
				signal that connectivity state back to the route server.
			</t>

		</abstract>

		<note title="Requirements Language">

			<t>
				The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
				NOT",
				"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
				are to
				be interpreted as described in
				<xref target="RFC2119" />
				only when they appear in all upper
				case. They may also appear in
				lower or mixed case as English
				words, without normative meaning.
			</t>

		</note>

	</front>

	<middle>
		<section anchor="intro" title="Introduction">
			<t>
				In configurations (typically Internet Exchange Points (IXPs))
				where EBGP routing information is exchanged between client
				routers through the agency of a route server (RS) <xref
				target="RFC7947" />, but traffic is exchanged directly,
				operational issues can arise when partial data plane
				connectivity exists among the route server client routers.
				Since the data plane is not congruent with the control plane,
				the client routers on the IXP can lose data connectivity
				without the control plane - the route server - being aware of
				it, resulting in significant data loss.
			</t>
			<t>
				To remedy this, two basic problems need to be solved:
				<list style="numbers">
				<t>Client routers must have a means of verifying connectivity
				amongst themselves, and</t>
				<t>Client routers must have a means of communicating the knowledge
				of the failure back to the route server.</t>
				</list>
			</t>
			<t>
				The first can be solved by application of Bidirectional
				Forwarding Detection <xref target="RFC5880" />. The second can
				be solved by exchanging BGP routes which use the NH-Reach
				Subsequent Address Family Identifier (SAFI) defined in this
				document.
			</t>
			<t>
				Throughout this document, we generally assume that the route
				server being discussed is able to represent different RIBs
				towards different clients, as discussed in <xref
				target="RFC7947">section 2.3.2.1 of</xref>. If this is not
				the case, the procedures described here to allow BFD to be 
				automatically provisioned between clients still have value;
				however, the procedures for signaling reachability back to the
				route server may not.
			</t>
			<t>
				Throughout this document, we refer to the "route server", "RS"
				or just "server" and the "client" to describe the two BGP
				routers engaging in the exchange of information. We observe
				that there could be other applications for this extension. Our
				use of terminology is intended for clarity of description, and
				not to limit the future applicability of the proposal.
			</t>

		</section>
		<section anchor="definitions" title="Definitions">
			<t>
				<list style="symbols">
					<t>
						Indirect peer: If a route server is configured such
						that routes from a given client might be sent to some
						other client, or vice-versa, those two clients are
						considered to be indirect peers.
					</t>
					<t>
						RS: Route Server. See <xref target="RFC7947"/>.
					</t>
				</list>
			</t>
		</section>

		<section anchor="overview" title="Overview">
			<t>
				As with the base BGP protocol, we model the function of this extension
				as the interaction between a conceptual set of databases:
			</t>
			<t>
				<list style="symbols">
					<t>
						ReachAsk: The reachability request database. A database of 
						nexthops (host addresses) for which data plane reachability
						is being queried. 
					</t>
					<t>
						ReachAsk-Out: A set of queries sent to the client.
					</t>
					<t>
						ReachAsk-In: A set of queries received from the route server.
					</t>
					<t>
						ReachTell: The reachability response database. A database of
						responses to ReachAsk queries, indicating what is known about
						data plane reachability.
					</t>
					<t>
						ReachTell-Out: The responses being sent to the route server.
					</t>
					<t>
						ReachTell-In: The response received from the client.
					</t>
					<t>
						LocReach: The local reachability database. Content can be
						derived from BFD or other sources, as appropriate.
					</t>
					<t>
					    NHIB: Next Hop Information Base. Stores what is known about
					    the client's reachability to its next hops. Content can be
					    derived from ReachTell-In or other sources, as appropriate.
					</t>
				</list>
			</t>
			<!-- XXX discussion point: I (jgs) started with "req(uest)" and "resp(onse)"
			 but switched to "ask" and "tell" because "response" implies you only tell
			 the server in response to a query, but I thought it might be a good idea to
			 leave the door open to a client provided unsolicited information. The term
			 "tell" is intednded to suggest I might choose to tell you something even if 
			 you didn't ask. -->
			 
<figure title="Route Server, RS Client, and Reachability Ask and Tell
databases with In/Out Queues" align="center">
   <artwork><![CDATA[
+--------------------------------------------------------+
|   +------------+    +------------+    +------------+   |
|   |    Per-    |    | Configured |    |    Per-    |   |
|   |   Client   |    |  indirect  |    |   Client   |   |
|   |    NHIB    |    |   peers    |    |    RIB     |   |
|   +-----^------+    +------------+    +-----+------+   |
|         |                         \         |          |
|   +-----+------+                   \-->-----v------+   |
|   |ReachTell-In|                      |ReachAsk-Out|   |
|   +------^-----+     Route Server     +-----+------+   |
+----------|----------------------------------|----------+
           |                                  |           
           |                                  |           
           |                                  |
           |                                  |
+----------|----------------------------------|----------+
|   +------+------+       RS Client     +-----v-----+    |
|   |ReachTell-Out|                     |ReachAsk-In|    |
|   +------^------+                     +-----+-----+    |
|          |          +------------+          |          |
|          |          |            |          |          |
|          `----------+  LocReach  <----------'          |
|                     |            |                     |
|                     +------------+                     |
+--------------------------------------------------------+
   ]]></artwork>
 </figure>
 
 <!-- XXX discussion: the figure is not quite accurate since the
  ReachAsk-In doesn't actually drive the LocReach. Actually, 
  ReachTell-Out is a function of both ReachAsk-In and LocReach. 
  Not sure how or if to diagram that, though.   -->

			<t>
				In outline, the route server requests its client to track
				connectivity for all the potential next hops the RS might send
				to the client, by sending these next hops as ReachAsk
				"routes". The client tracks connectivity, using BFD or
				otherwise, and reports its connectivity status to the RS using
				ReachTell "routes". Connectivity status may be that the next
				hop is reachable, unreachable, or unknown. Once the RS has
				been informed by the client of its connectivity, it uses this
				information to influence the route selection the RS performs
				on behalf of the client. Details are elaborated in the
				following sections.
			</t>
		</section>
		
		<section anchor="nh_validation" title="Next Hop Validation">
			<t>
				Below, we detail procedures where a route server tells its
				client router about other client nexthops by sending it
				ReachAsk routes and the client router verifies connectivity to
				those other client routers (using BFD or otherwise) and
				communicates its findings back to the RS using ReachTell
				routes. The RS uses the received ReachTell routes as input to
				the route selection process it performs on behalf of the
				client.
			</t>

			<section anchor="reachask" title="ReachAsk">
				<t>
					The route server maintains a ReachAsk database for each
					client that supports this proposal, that is, for each
					client that has advertised support for the NH-Reach SAFI.
					This database is a set comprising the union of:
					
					<list style="symbols">
						<t>
							The set of next hops found in the
							associated per-client Loc-RIB (see <xref
							target="RFC7947">section 2.3.2.1 of</xref>).
						</t>
						<t>
							The set of addresses of this client's <xref
							target="definitions">indirect peers</xref>.
							(Discussion: This functionality ensures that BFD
							sessions will already be provisioned when needed.
							More importantly, it ensures that both ends of the
							BFD session will be provisioned, even in the case
							where routes flow only in one direction between a
							pair of clients.) (XXX I can think of various other
							ways to do this, e.g. we could do it all with NH
							gleaning from the per-client RIB, but if we notice
							we are sending client A a ReachAsk for NH B, then
							at that point we go make sure we are sending
							client B a ReachAsk for NH A. We don't have to
							drive it from configuration. Maybe it's good to do
							it that way anyway? In any case, probably delete
							the "discussion" parenthetical?)
						</t>
						<t>
							The RS MAY also add other entries, for example
							under configuration control.
						</t>
						<t>
							XXX discussion question: do we do this for
							all indirect peers, or just ones that have 
							advertised support for NH-Reach? I think all,
							after all, might not the indirect peer have
							manually provisioned BFD? A similar question
							(and answer) applies for gleaned next hops.
						</t>
					</list>
				</t>
				
				<t>
					The contents of the ReachAsk database are communicated to
					the client using the NLRI format and procedures described
					<xref target="advertising">below</xref>.
				</t>
			</section>
			
			<section anchor="locreach" title="LocReach">
				<t>
					The client MUST attempt to track data plane connectivity
					to each host address depicted in the ReachAsk database. It
					MAY also track connectivity to other addresses. This
					document discusses the use of BFD for this purpose,
					detailed in <xref target="client_procedures"/>; other 
					means are possible as well. 
				</t>
				
				<t>
					For each address being tracked, a LocReach entry is created
					to indicate its state. The state can be:
					
					<list style="symbols">
						<t>Unknown. Connectivity status is unknown. This may be
						due to a temporary or permanent lack of feasible OAM
						mechanism to determine the status. </t>
						<t>Up. The address has been determined to be
						reachable.</t>
						<t>Down. The address has been determined to be 
						unreachable.</t>
					</list>
					
					The LocReach database is used as input for the ReachTell
					database; it MAY also be used as input to the route
					resolvability condition (<xref target="RFC4271">section
					9.1.2.1 of</xref>).
				</t>
				
			</section>
			
			<section anchor="reachtell" title="ReachTell">
				<t>
					The ReachTell database contains an entry for every
					entry in the LocReach database.
				</t>
				
				<t>
					The contents of the ReachTell database are communicated to
					the server using the NLRI format and procedures described
					<xref target="advertising">below</xref>.
				</t>
			</section>
			
			<section anchor="nhib" title="NHIB">
				<t>
					The route server maintains a per-client Next Hop
					Information Base, or NHIB. This contains the information
					about next hop status received from ReachTell.
				</t>

				<t>
					In computing its per-client Loc-RIB, the RS uses the
					content of the related per-client NHIB as input to the
					route resolvability condition (<xref
					target="RFC4271">section 9.1.2.1 of</xref>). The next 
					hop being resolved is looked up in the NHIB and its state
					determined:

					<list style="symbols">
						<t>Reachable next hops are considered resolvable.</t>
						<t>Unknown next hops MAY be considered resolvable.
						They MAY be considered less preferable for
						selection.</t>
						<t>Unreachable next hops MUST NOT be considered 
						resolvable.</t>
						<t>If a given next hop is not present in the NHIB, but
						is present in ReachAsk-Out, either the client has not
						responded yet (a transient condition) or an error
						exists. Similar to Unreachable next hops, such routes
						MAY be considered resolvable; they MAY be considered
						less preferable.</t>
					</list>
				</t>
			</section>
		</section>
		
<!--
		<section anchor="operation_old" title="Operation (old)">
			<t>
				Below, we detail procedures where a route server tells its
				client router about other client nexthops by sending it
				ReachAsk routes and the client router verifies connectivity to
				those other client routers (using BFD or otherwise) and
				communicates its findings back to the RS using ReachTell
				routes. The RS uses the received ReachTell routes as input to
				the route selection process it performs on behalf of the
				client.
			</t>

			<section anchor="discovery"
				title="Mutual Discovery of Route Server Client Next Hops">
				<t>
					Strictly speaking, a route server client does not need to know of
					other control-plane clients. For validation purposes, it only needs
					to know the set of next hops the route server might choose to send to
					it; i.e., to know all potential forwarding plane relationships.
				</t>

				<t>
					This requirement amounts to knowing the BGP next hops the
					route server is aware of for the particular per-client Loc-RIB
					(see <xref target="RFC7947">section 2.3.2.1 of</xref>).
					We introduce a new table for each client to store known next hops, their
					compatibility with this proposed solution and their learned reachability. We
					call these tables per-client Next Hop Information Base (NHIB). The NHIB is
					communicated to the Route Server using ReachTell routes. The NHIB and 
					associated tables will generally be of modest size; the set of routers
					in the ASes the client indirectly peers with via the RS.
				</t>

				<t>
					At the route server, the ReachAsk-Out for each client is populated with the next
					hops from its Per-Client-RIB.  ((If the BGP capabilities learned during BGP session setup
					identify a next hop as compatible with this proposal, this is reflected in the
					NHIB XXX. Initially, it is assumed that the client router is able to reach its next
					hops which are stored in the NHIB.))  If a next hop is added to the Per-Client-RIB for a
					particular client, a route MUST be added to the route server's ReachAsk-Out.
				</t>

				<t>
					A route server client SHOULD use <xref
					target="RFC5880">BFD</xref> (or other means beyond the
					scope of this document) to track forwarding plane
					connectivity to each next hop in its ReachAsk-In as
					received from the RS's ReachAsk-Out, as detailed below.
				</t>

			</section>

			<section anchor="tracking" title="Tracking Connectivity">
				<t>
					For each next hop in its ReachAsk-In, the client router
					SHOULD use some means to confirm that data plane
					connectivity exists to that next hop.  Here we assume BFD.
				</t>

				<t>
					The client router maintains its own LocReach database in
					order to keep track of its (potential) next hops and their
					reachability. LocReach is updated according to the
					ReachAsk-In and client router's own tests to verify
					connectivity to next hops.
				</t>
				
				<t>	
					For each next hop in the ReachAsk-In, the client router
					SHOULD attempt to establish a BFD session if one is not
					already established, and track the reachability of this
					next hop.
				</t>
				-->
<!--XXX
				<t>
					For each nexthop that is determined to be reachable, an
					entry should be added in the client router's Adj-NHIB-Out
					to be advertised to the route server. Similarly, when that
					nexthop is determined to no longer be reachable, the entry
					should be removed from the client router's Adj-NHIB-Out.
					This may also be done as a result of policy even if
					connectivity exists.
				</t>

				<t>
					If the client cannot establish a BFD session with an entry in its
					NHIB, the next hop is put in the Adj-NHIB-Out for backward
					compatibility.
				</t>
			-->	
			<!--
				<t>
					If the test of connectivity between one client router and
					another client router fails, the client router detecting
					this failure should perform the connectivity test for a
					configurable amount of time, preferably 24 hours. If
					during this time no connectivity can be restored no more
					testing is performed until manually changed or the client
					router is rebooted.
				</t>
			</section>
		</section>
		
		<section anchor="client-advertising" title="Advertising Client Router Connectivity to the Route Server">
			<t>
				As discussed above, a client router will advertise the content
				of its LocReach database to the route server through its
				ReachTell-Out. The route server SHOULD update the reachability
				information of next hops in the client's NHIB table
				accordingly. Furthermore, the route server SHOULD use
				reachability information from the NHIB as input to its own
				decision process when computing the Adj-RIB-Out for this
				client. This client-dependent Adj-RIB-Out is then advertised
				to this client. In particular, the route server MUST exclude
				any routes whose next hops the client has declared to be not
				reachable.
			</t>
		</section>
		-->

		<section anchor="advertising" title="Advertising NH-Reach state in BGP">
<!--			<t>
				Two distinct pieces of per-peer state have been identified in the sections above:
			</t>
			<t>
				<list style="symbols">
					<t>
						The set of next hops for BGP routes received from the
						BGP speaker, the Adj-NHIB-In.
					</t>
					<t>
						The set of next hops the BGP speaker is advertising as
						reachable, i.e., has potential connectivity to, the
						Adj-NHIB-Out.
					</t>
				</list>
			</t>-->

			<section title="Using the NH-Reach SAFI">
				<t>
					A new BGP SAFI, the NH-Reach SAFI, is defined in this
					document.  It has been assigned value TBD.  A route server
					or a route server client using the procedures in this
					document MUST advertise support for this SAFI, for the
					IPv4 and/or IPv6 Address Family Identifier (AFI). The use
					of this SAFI with any other AFI is not defined by this
					document.
				</t>
				<t>
					NH-Reach NLRI "routes" have a Length of Next Hop Network
					Address value of 0, therefore they have an empty Network
					Address of Next Hop field (<xref target="RFC4760">section
					3 of</xref>).
				</t>
				<t>
					Since as specified here, ReachTell "routes" from different
					clients populate distinct databases on the RS, there will
					generally be only a single path per "route"; this implies
					that route selection need not be performed (or
					equivalently, that it's trivial to perform).
				</t>
				<t>
					In the other direction, a client might peer with multiple
					route servers and receive differing sets of ReachAsk
					routes from them. An implementation MAY handle this
					situation by implementing a distinct ReachAsk and
					ReachTell per server, but it MAY also handle it by placing
					all servers' ReachAsk "routes" into a single ReachAsk, and
					sending the results to all servers from a single
					ReachTell. This would imply some route server(s) might get
					ReachTell results they had not asked for, but this is
					permissible in any case. Again, since the contents of
					ReachAsk are simply a set of host routes to be tested,
					route selection over a combined ReachAsk MAY be omitted.
				</t>
				<t>
				    ReachAsk and ReachTell entries are exchanged using the
				    NH-Reach NLRI encoding: 
				</t>
                <figure title="NH-Reach NLRI Format" 
                		align="center"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      type     |          next hop (4 or 16 octets)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
.             ...  next hop (4 or 16 octets) ...                .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                ]]></artwork></figure>
                                
                <t><list style="symbols">
                	<t>The Type field can take the value 0, meaning the
                	   NLRI is a ReachAsk entry, or 1, meaning it is a
                	   ReachTell entry. All other values are reserved, NLRI
                	   with some other value in this field MUST be ignored on
                	   receipt.</t>
                	<t>The next hop field is an IPv4 or IPv6 host
                	   route, depending on whether the AFI is IPv4
                	   or IPv6.</t>
                </list></t>

				<t>
					ReachAsk and ReachTell entries MUST NOT be propagated from
					one BGP peering session to another; the routes are not
					transitive.  To help enforce this expected behavior, such
					routes MUST carry the NO_ADVERTISE community <xref
					target="RFC1997"/>.  NH-Reach routes not carrying this
					community MUST be handled using the "treat-as-withdraw"
					option specified in <xref target="RFC7606"/> section 2.
					(XXX I'm not sure this belt-and-braces is really needed,
					but I don't have strong feelings about it so have left it
					in, in case someone else wants to stand up for it. If 
					nobody advocates for it, I'll plan to cut it out.)
				</t>
				<t>
					If a ReachAsk entry is received from a BGP speaker and
					that entry is not part of the sub-network for that BGP
					session, that NLRI SHOULD be ignored unless the feature is
					being used in a multihop context (such use is outside the
					scope of this document). This prevents erroneous BFD
					peering sessions being provisioned outside of the IXP
					network. (XXX I am a little confused about this paragraph,
					leaving it for further discussion. By the way, apart from
					other issues, there's the corner case where a entry is 
					received and ignored, but instants later an interface is
					configured for that subnetwork such that the entry wouldn't 
					have been ignored. Do we rewind history and get it back?)
				</t>
			</section>
<!--
			<section anchor="indirect_peer" title="Specific Procedures for Route Server Clients">
				<t>
					If a route server is configured such that routes from a
					given client A might be sent to a given client B, or
					vice-versa, those two clients are considered to be
					indirect peers. A route server MUST always place an entry
					in a client's ReachAsk-Out for any indirect peer of that
					client. The value to be used for the entry is the
					configured peering address in question.
				</t>
				<t>
					Discussion: This functionality ensures that BFD sessions
					will already be provisioned when needed. More importantly,
					it ensures that both ends of the BFD session will be
					provisioned, even in the case where routes flow only in
					one direction between a pair of clients.
				</t>
				<t>
					XXX I can think of various other ways to do this, e.g.
					we could do it all with NH gleaning from the per-client RIB,
					but if we notice we are sending client A a ReachAsk for NH
					B, then at that point we go make sure we are sending client
					B a ReachAsk for NH A. We don't have to drive it from 
					configuration. Maybe it's good to do it that way anyway?
				</t>
			</section>
			-->
			<section anchor="state_comm" title="The NH-Reach State Community">
<!--                                <figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      0x43     | Sub-Type TBD1 |    Reserved (Must be Zero)    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Reserved (Must be Zero)         |     State     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                ]]></artwork></figure>

				<t>
					The NH-Reach State Extended Community is used to signal
					the reachability state of the associated NH-Reach NLRI.  A
					one-octet field is used for this purpose.  The remainder
					of the extended community is reserved and its contents
					MUST be set to zero when originated and MUST be ignored
					upon receipt. 
					
					XXX I stubbed this out because I couldn't think of why we
					need an extcomm instead of a regular one. It's not a big deal,
					but it seemed fine to just use a regular and save a few
					bits. If you want to put it back, no worries.
				</t>-->
				
				<t>
					The NH-Reach State Well-Known Community has value TBD. The
					low-order bytes of the community encode the reachability
					state of the associated NH-Reach NLRI:
				</t>
				
                <figure title="NH-Reach State Well-Known Community" 
                		align="center"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               TBD             |              State            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                ]]></artwork></figure>
				
				<t>
					State may take on the following values:
					<list style="symbols">
						<t>0: Unknown.</t>
						<t>1: Reachable.</t>
						<t>2: Unreachable.</t>
					</list>
					The values 3-65535 are reserved. If a community with a
					value in this range is received then it MUST be treated as
					though the value had been 2, Unreachable. (XXX Unknown is
					another option. So is treat-as-withdraw but that amounts
					to Unknown the way the spec is currently written.)
				</t>
				<t>
					The NH-Reach State Community MUST be sent
					with any ReachTell route. NH-Reach routes not carrying this
					community MUST be handled using the "treat-as-withdraw"
					option specified in <xref target="RFC7606"/> section 2.
					If this community is received with any other route, including
					a ReachAsk route, it MUST be ignored. 
				</t>
			</section>
		</section>

		<section title="Processing NH-Reach State Changes">
			<section anchor="client_procedures" 
					 title="Route Server Client Procedures for NH-Reach Changes">
				<t>
					When entries are added to a route server client's ReachAsk-In for a route
					server peering session, the client will then attempt to verify connectivity to the
					host depicted by that entry.  The procedure described in this specification utilizes
					BFD; other mechanisms are permitted but are out of scope of this document.
				</t>
				<t>
					If no existing BFD session exists to this nexthop, a BFD
					session is provisioned to that IP address and the LocReach
					<xref target="state_comm">Reachable state</xref> is set to
					Unknown.  Since this session requires the remote BFD
					session to also be provisioned, it may stay in the
					Down/AdminDown state for a period of time.
				</t>
				<t>
					If the client cannot establish a BFD session with an entry
					in its ReachAsk-In, the nexthop remains in 
					LocReach with its Reachable state Unknown.
				</t>
				<t>
					Once the BFD session moves to the Up state, the LocReach
					Reachable state is set to Up.  <!-- This entry is now eligible
					to be placed in ReachTell-Out table and distributed
					according to the procedures above.  Additionally, local
					BGP route selection may be impacted by this state.  See
					<xref target="routeselectionprocess"/>. -->
				</t>
				<t>
					When the BFD session transitions out of the Up state to
					the Down state, the LocReach Reachable state is set to
					Down.  <!-- The corresponding entry MUST be removed from the
					ReachTell-Out table.  This has the consequence of
					withdrawing the corresponding NH-Reach route, informing
					the route server that the next hop is no longer reachable. -->
				</t>
				<t>
					If the BFD session transitions out of the Up state to the
					AdminDown state, the LocReach Reachable state is set to
					Unknown<!-- AdminDown-->.  <!--The corresponding entry is not be removed from
					the ReachTell-Out table.  Instead, the NH-Reach State
					Extended Community is added to the route with the R
					(reachable) bit clear.  -->
				</t>
<!--
				<t>
					The motivation for this behavior is that AdminDown could imply
					one of two possible circumstances:
					
					<list style="symbols">
						<t>The local BFD session has been deconfigured and BFD validation is no
						longer possible.  While the nexthop may still be usable, it is no longer
						able to be determined using BFD whether that can happen.  Removing the
						entry from the Adj-NHIB-Out will inform the route server that the next
						hop is no longer reachable and may adversely impact the route server's
						view supplied to that route server client.</t>
						<t>The remote BFD session has been deconfigured with similar impact.</t>
					</list>

					An implementation of these procedures MUST provide an administrative mechanism
					to clear such AdminDown entries from the Adj-NHIB-Out table. XXX I guess?
					But why? As the procedures are now written, this is not distinguishable on the
					wire from a session where BFD never came up to begin with.
				</t>
-->
				<t>
					When entries are removed from the route server client's
					ReachAsk-In for a route server peering session, the client
					MAY delay de-provisioning the BFD peering session.  If the
					client delays de-provisioning the session, it should
					remove it if the BFD session transitions to the Down or
					AdminDown states. <!--The client SHOULD remove the
					corresponding entry from its LocReach and hence,
					ReachTell-Out tables regardless of the state of the BFD
					session.-->
				</t>
			</section>
<!--
			<section title="Route Server Procedures for NH-Reach Changes">
				<t>
					A route server creates an entry in its ReachAsk-Out database
					for each distinct nexthop in the associated Per-Client RIB,
					and for each <xref target="definitions">indirect peer</xref> 
					associated with the client in question. (XXX see discussion
					in that section about whether we really need both of these)
					It MAY also create entries for other reasons, for example under
					configuration control.
				</t>
				<t>
					In computing its per-client Loc-RIB, the route server uses
					the content of the related per-client NHIB:
					
					<list style="symbols">
						<t>If a given next hop is present with state
						Reachable, it has been validated to be reachable by
						the client. Routes with such next hops are considered
						eligible for selection for purposes of <xref
						target="RFC4271">section 9.1.2.1 of </xref></t>
						<t>If a given next hop is present with state Unknown,
						the client is unable to supply information about its
						reachability state. Routes with such next hops MAY be
						considered eligible for selection for purposes of
						<xref target="RFC4271">section 9.1.2.1 of </xref> .
						They MAY be considered less preferable for
						selection.</t>
						<t>If a given next hop is not present, it is
						considered unreachable by the client. Such routes MUST
						NOT be considered eligible for selection for purposes
						of <xref target="RFC4271">section 9.1.2.1 of
						</xref></t>
					</list>
				</t>
			</section>
			-->
		</section>
		
		<section anchor="recommendations" title="Recommendations for Using BFD">
				<t>
					The RECOMMENDED way a client router can confirm the data plane
					connectivity to its next hops is available, is the use of BFD in
					asynchronous mode. Echo mode MAY be used if both client routers running
					a BFD session support this. The use of authentication in BFD is
					OPTIONAL as there is a certain level of trust between the
					operators of the client routers at a particular IXP. If trust cannot
					be assumed, it is recommended to use pair-wise keys (how this can be
					achieved is outside the scope of this document).
					The ttl/hop limit values as described in
					<xref target="RFC5881">section 5</xref>
					MUST be obeyed in order to shield BFD sessions against packets
					coming from outside the IXP.
				</t>
				<t>XXX I assume the preceding paragraph means everyone at the IX 
				has to configure their router with all these parameters? Would it
				be reasonable for the route server to supply the parameters instead?
				Do the participants have to agree? (I'm sorry, my BFD is very rusty.)
				(Obviously they have to agree if keying is used, but for the other
				parameters.)</t>
				
				<t>
					There is interdependence between the functions described in
					this document and BFD from an administrative point of view.
					To streamline behaviour of different implementations the following
					are RECOMMENDED:
					<list style='symbols'>
						<t>If BFD is administratively shut down by the administrator of
						a client router then the functions described in this document
						MUST also be administratively shut down. (XXX discussion: 
						what does this mean exactly? Must we reset the BGP session because
						we have to remove the SAFI? If so, why do we have that language
						that talks about advertising the routes with the bit clear to 
						indicate "unknown" state in the AdminDown case? In any case, once
						we agree what should happen here, probably need to elaborate 
						this clause. Come to think of it, I assume what is really meant
						here is "if you can't do OAM any more you have to remove the SAFI".
						I guess?)</t>
						<t>If the administrator enables the functions described in
						this document on a client router then BFD MUST be automatically
						enabled. (XXX is there scope to say that BFD need only be enabled
						towards the routers requested in ReachAsk? Also, if we are going 
						to "automatically enable" BFD I suppose either the configuration
						stanza that enables NH-Reach also has mandatory parameters for the 
						BFD params, or they just default to what's specced here, or...?)</t>
					</list>
				</t>
				
				<t>
					The following values of the BFD configuration of client routers
					(see <xref target="RFC5880">section 6.8.1</xref>) are RECOMMENDED in
					order to allow fast detection of lost data plane connectivity:
					<list style='symbols'>
						<t>DesiredMinTxInterval: 1,000,000 (microseconds)</t>
						<t>RequiredMinRxInterval: 1,000,000 (microseconds)</t>
						<t>DetectMult: 3</t>
					</list>
				</t>
<!-- 
XXX I stubbed this out because while interesting it probably doesn't really matter
that much to the implementor, who's just going to do what you tell them to do. This is
a matter of taste, some people like to make their specs tutorial (cough OSPF cough)
so I won't argue if some or all is re-added.

				<t>
					The configuration values above are a trade-off between fast detection of data
					plane connectivity and the load client routers must handle keeping up the BFD
					communication. Selecting smaller DesiredMinTxInterval and RequiredMinRxInterval
					values generates excessive BFD packets, especially at larger IXPs with many
					hundreds of client routers. 
				</t>

				<t>
					The configuration values above were chosen to accept brief
					interruptions in the data plane.  Otherwise, if a BFD session detects a brief
					data plane interruption to a particular client router, it will signal to the
					route server that it should remove routes from this client router and shortly
					thereafter to add the routes again. This is disruptive and computationally
					expensive on the route server.
				</t>

				<t>
					The configuration values above are also partially impacted by BGP advertisement
					time in reaction to events from BFD. If the configuration values are selected so
					that BFD detects data plane interruptions faster than the BGP advertisement
					time, a data plane connectivity flap could be detected by BFD but the route
					server is not informed about it because BGP is not able to transport this
					information quickly enough.
				</t>
-->
				<t>
					<!-- As discussed, f-->Finding good configuration values is hard, so a client router
					administrator MAY select more appropriate values to meet the special needs of
					a particular deployment.
				</t>

            	<!-- BFD flapping handling meachanism -->
            	<!-- Comment Jeff: Whether we need to specify that the remote
            	nexthop reachability mechanism is damped in the spec is an
            	open question. -->
		</section>
		<!--
XXX I think this is now covered in the main body of the spec, where it says that 
Unknown and missing NH are considered eligible for selection.

		<section anchor="bootstrapping" title="Bootstrapping">
			<t>
				During route server start-up, it does not know anything about connectivity states
				between client routers. So, the route server assumes optimistically that all
				client routers are able to reach each other unless told otherwise.
			</t>
		</section>
-->

		<section anchor="other" title="Other Considerations">
			<t>
				For purposes of routing stability, implementations may wish to apply
				hysteresis ("holddown") to next hops that have transitioned from
				reachable to unreachable and back. 
			</t>
		</section>

		<section title="IANA Considerations">
			<t>
				IANA is requested to allocate a value from the Subsequent Address Family Identifiers
				(SAFI) Parameters registry for this proposal.  Its Description in that registry shall
				be NH-Reach with a Reference of this RFC.
			</t>
			<!--
			<t>
				IANA is requested to allocate a value from the Non-Transitive Opaque Extended Community
				Sub-Types registry.  Its Name will be "NH-Reach State Extended Community" with a
				Reference of this RFC.
			</t>
			-->
			<t>
				IANA is requested to allocate a value from the Border Gateway
				Protocol (BGP) Well-known Communities registry.  Its Name will
				be "The NH-Reach State Community" with a Reference of this RFC.
			</t>
		</section>

		<section title="Security Considerations">
			<t>
				The mechanism in this document permits route server clients to
				influence the contents of the route server's Adj-Ribs-Out
				through its reports of next hop reachability state using the
				NH-Reach SAFI.  Since this state is per-client, if a route
				server client is able to inject NH-Reach routes for another
				route server's BGP session to a client, it can cause the route
				server to select different forwarding than otherwise expected.
				This issue may be mitigated using transport security on the
				BGP sessions between the route server and its clients.  See
				<xref target="RFC4272"/>.
			</t>
			<t>
				Should route server clients provision the NH-Reach SAFI amongst
				themselves, it would be an error but would have no undesired impact on
				forwarding.  (XXX would it really be an error, is it necessary to say this?
				it seems to me that although we have currently written this in terms of a 
				route server and its clients, it really could apply in any case where
				third-party next hops are in use. In any case since it's a no-op, do we 
				really need to say it in this section?)  It is incorrect provisioning for an IXP client which is using a
				Route Server to have a BGP session with another IXP client. (XXX really? why?) Should they
				negotiate the NH-Reach SAFI and send NH-Reach routes, this only
				serves to signal that BGP Speaker, when not operating as a route server, to
				attempt to set verify connectivity with the hosts in the received NLRI.
				While this may potentially request a large number of sessions, the default
				BFD timers prevent excess packets from being sent from inappropriately
				provisioned sessions. (XXX ok I do see that lots of BFD sessions could be a concern that needs to be
				addressed in this section)
			</t>
			<t>
				The reachability tests between route server clients themselves may be a target for
				attack.  Such attacks may include forcing a BFD session Down through injecting false BFD
				state.  A less likely attack includes forcing a BFD session to stay Up when its real
				state is Down.  These attacks may be mitigated using the BFD security mechanisms defined
				in <xref target="RFC5880"/>.
			</t>
		</section>
	</middle>

	<back>

		<references title="Normative References">
		&RFC1997;
		&RFC2119;
		&RFC4271;
		&RFC4760;
		&RFC5880;
		&RFC5881;
		&RFC7606;
		&RFC7947;
		</references>
		<references title="Informative References">
		&RFC4272;
		</references>

<!--
XXX I'm not sure what the purpose of this section is so I've stubbed it out.
Also, because the parser doesn't like runs of hyphens inside a comment, I've
replaced the hyphen runs with percent signs, simply because there is no other
occurrance in the document so it'll be easy enough to restore them with a simple
search-and-replace if needed.

		<section title="Summary of Adj-NHIB-In state">
			<t>
				The Adj-NHIB-In state is maintained per BGP peering session.  It consists of per-peer
				state and per-peer, per-nexthop state.
			</t>
                        <t>
                                <figure><artwork><![CDATA[
 +%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%+%%%%%%%%%%%%%%%%%%%%%%%%%%%%+
 | Client Role                       | (Route-Server |            |
 |                                   |  Route-Server-Client       |
 +%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%+%%%%%%%%%%%%%%%%%%%%%%%%%%%%+
             Fig. 1  Per-peer Adj-NHIB-In Table State


+%%%%%%%%%%%%%%%%%%%%%%%%%%%+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%+
| NextHop                   | <IPv4 Address | IPv6 Address         |
+%%%%%%%%%%%%%%%%%%%%%%%%%%%+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%+
| Reachable                 | (Unknown | Up | Down | AdminDown)    |
+%%%%%%%%%%%%%%%%%%%%%%%%%%%+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%+
              Fig. 2  Per-peer, per-nexthop  Adj-NHIB-In State

                                ]]></artwork></figure>
                        </t>

		</section>
-->

		<section title="Summary of Document Changes">
		    <t>
		    <list style="hanging" hangIndent="2">
		    <t hangText="idr-02 to idr-03:">Substantial rewrite.</t>
			<t hangText="idr-01 to idr-02:">Move from BGP-LS to NH-Reach SAFI.
			   Lots of editorial changes.</t>
			<t hangText="idr-00 to idr-01:">Add BGP Capability.  Move from NH-Cost to BGP-LS.</t>
			<t hangText="ymbk-01 to idr-00:">No technical changes; adopted by IDR.</t>
			<t hangText="ymbk-00 to ymbk-01:">Clarifications to BFD procedures. Use BFD state
			   as an input to BGP route selection.</t>

		    </list>
		    </t>
		</section>
	</back>

</rfc>
